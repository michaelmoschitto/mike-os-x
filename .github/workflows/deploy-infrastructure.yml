name: Deploy Infrastructure

on:
  push:
    branches: [main]
    paths:
      - 'iac/**'
  workflow_dispatch:
    inputs:
      ssh_public_key:
        description: 'SSH public key for EC2 access (or use EC2_SSH_PUBLIC_KEY secret)'
        required: false
        type: string

jobs:
  deploy-infrastructure:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Pulumi
        uses: pulumi/actions@v5

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        working-directory: iac
        run: bun install

      - name: Validate required secrets
        run: |
          MISSING_SECRETS=()

          if [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ]; then
            MISSING_SECRETS+=("AWS_ACCESS_KEY_ID")
          fi

          if [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
            MISSING_SECRETS+=("AWS_SECRET_ACCESS_KEY")
          fi

          if [ -z "${{ secrets.PULUMI_PASSPHRASE }}" ]; then
            MISSING_SECRETS+=("PULUMI_PASSPHRASE")
          fi

          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "::error::Missing required GitHub secrets: ${MISSING_SECRETS[*]}"
            echo "Please configure these secrets in your repository settings:"
            for secret in "${MISSING_SECRETS[@]}"; do
              echo "  - $secret"
            done
            exit 1
          fi

          echo "✅ All required secrets are configured"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2

      - name: Set Pulumi passphrase
        run: |
          echo "PULUMI_CONFIG_PASSPHRASE=${{ secrets.PULUMI_PASSPHRASE }}" >> $GITHUB_ENV

      - name: Login to Pulumi
        run: pulumi login --local

      - name: Select or create stack
        working-directory: iac
        run: |
          STACK="${{ secrets.PULUMI_STACK || 'default' }}"
          if ! pulumi stack ls | grep -q "$STACK"; then
            pulumi stack init "$STACK"
          else
            pulumi stack select "$STACK"
          fi

      - name: Set SSH public key
        working-directory: iac
        run: |
          SSH_KEY="${{ github.event.inputs.ssh_public_key || secrets.EC2_SSH_PUBLIC_KEY }}"
          if [ -z "$SSH_KEY" ]; then
            echo "::error::SSH public key is required but not provided."
            echo "Please either:"
            echo "  1. Set the EC2_SSH_PUBLIC_KEY secret in repository settings, or"
            echo "  2. Provide it as a workflow input when manually triggering the workflow"
            exit 1
          fi
          pulumi config set sshPublicKey "$SSH_KEY"

      - name: Preview changes
        working-directory: iac
        run: pulumi preview --non-interactive

      - name: Deploy infrastructure
        working-directory: iac
        run: pulumi up --yes --non-interactive

      - name: Get EC2 IP
        id: get_ip
        working-directory: iac
        run: |
          EC2_IP=$(pulumi stack output publicIp --show-secrets)
          echo "EC2_IP=$EC2_IP" >> $GITHUB_OUTPUT
          echo "EC2 IP: $EC2_IP"

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ steps.get_ip.outputs.EC2_IP }} >> ~/.ssh/known_hosts

      - name: Wait for EC2 to be ready
        run: |
          echo "Waiting for EC2 instance to be ready..."
          EC2_IP="${{ steps.get_ip.outputs.EC2_IP }}"
          max_attempts=30
          attempt=0

          while [ $attempt -lt $max_attempts ]; do
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 -i ~/.ssh/id_rsa ubuntu@$EC2_IP echo "Connected" 2>/dev/null; then
              echo "✅ EC2 instance is ready"
              exit 0
            fi
            attempt=$((attempt + 1))
            echo "Attempt $attempt/$max_attempts: Waiting for SSH..."
            sleep 10
          done

          echo "::warning::EC2 instance may not be fully ready, but continuing..."

      - name: Generate TLS certificates
        run: |
          EC2_IP="${{ steps.get_ip.outputs.EC2_IP }}"
          CERTS_DIR="$(pwd)/certs"
          DAEMON_DIR="$CERTS_DIR/daemon"
          CLIENT_DIR="$CERTS_DIR/client"

          echo "Generating Docker TLS certificates for $EC2_IP..."

          mkdir -p "$DAEMON_DIR" "$CLIENT_DIR"

          # Generate CA private key
          openssl genrsa -out "$CERTS_DIR/ca-key.pem" 4096

          # Generate CA certificate
          openssl req -new -x509 -days 365 -key "$CERTS_DIR/ca-key.pem" \
              -sha256 -out "$CERTS_DIR/ca.pem" \
              -subj "/C=US/ST=State/L=City/O=Organization/CN=docker-ca"

          # Generate server private key
          openssl genrsa -out "$DAEMON_DIR/server-key.pem" 4096

          # Generate server certificate signing request
          openssl req -subj "/C=US/ST=State/L=City/O=Organization/CN=$EC2_IP" \
              -sha256 -new -key "$DAEMON_DIR/server-key.pem" \
              -out "$DAEMON_DIR/server.csr"

          # Create server certificate extensions
          echo "subjectAltName = IP:$EC2_IP,DNS:$EC2_IP,DNS:localhost,IP:127.0.0.1,IP:::1" > "$DAEMON_DIR/server-extfile.cnf"
          echo "extendedKeyUsage = serverAuth" >> "$DAEMON_DIR/server-extfile.cnf"

          # Generate server certificate
          openssl x509 -req -days 365 -sha256 \
              -in "$DAEMON_DIR/server.csr" \
              -CA "$CERTS_DIR/ca.pem" \
              -CAkey "$CERTS_DIR/ca-key.pem" \
              -CAcreateserial \
              -out "$DAEMON_DIR/server-cert.pem" \
              -extfile "$DAEMON_DIR/server-extfile.cnf"

          # Generate client private key
          openssl genrsa -out "$CLIENT_DIR/key.pem" 4096

          # Generate client certificate signing request
          openssl req -subj "/C=US/ST=State/L=City/O=Organization/CN=client" \
              -new -key "$CLIENT_DIR/key.pem" \
              -out "$CLIENT_DIR/client.csr"

          # Create client certificate extensions
          echo "extendedKeyUsage = clientAuth" > "$CLIENT_DIR/client-extfile.cnf"

          # Generate client certificate
          openssl x509 -req -days 365 -sha256 \
              -in "$CLIENT_DIR/client.csr" \
              -CA "$CERTS_DIR/ca.pem" \
              -CAkey "$CERTS_DIR/ca-key.pem" \
              -CAcreateserial \
              -out "$CLIENT_DIR/cert.pem" \
              -extfile "$CLIENT_DIR/client-extfile.cnf"

          # Copy CA cert to client directory
          cp "$CERTS_DIR/ca.pem" "$CLIENT_DIR/ca.pem"

          # Set proper permissions
          chmod 600 "$CERTS_DIR/ca-key.pem" "$DAEMON_DIR/server-key.pem" "$CLIENT_DIR/key.pem"
          chmod 644 "$CERTS_DIR/ca.pem" "$DAEMON_DIR/server-cert.pem" "$CLIENT_DIR/cert.pem"

          # Clean up temporary files
          rm -f "$DAEMON_DIR/server.csr" "$DAEMON_DIR/server-extfile.cnf" \
                "$CLIENT_DIR/client.csr" "$CLIENT_DIR/client-extfile.cnf" \
                "$CERTS_DIR/ca.srl"

          echo "✅ TLS certificates generated successfully"

      - name: Upload server certificates to EC2
        run: |
          EC2_IP="${{ steps.get_ip.outputs.EC2_IP }}"
          mkdir -p /tmp/certs
          cp certs/daemon/* /tmp/certs/
          cp certs/ca.pem /tmp/certs/

          scp -i ~/.ssh/id_rsa -r /tmp/certs/* ubuntu@$EC2_IP:/tmp/certs/
          echo "✅ Server certificates uploaded to EC2"

      - name: Configure Docker TLS on EC2
        run: |
          EC2_IP="${{ steps.get_ip.outputs.EC2_IP }}"
          ssh -i ~/.ssh/id_rsa ubuntu@$EC2_IP << 'EOF'
            set -e
            echo "Configuring Docker TLS..."
            
            # Copy certificates to Docker certs directory
            sudo mkdir -p /etc/docker/certs
            sudo cp /tmp/certs/* /etc/docker/certs/
            sudo chmod 600 /etc/docker/certs/server-key.pem
            sudo chmod 644 /etc/docker/certs/ca.pem /etc/docker/certs/server-cert.pem
            
            # Configure Docker daemon
            sudo tee /etc/docker/daemon.json > /dev/null <<'DOCKER_EOF'
            {
              "hosts": ["unix:///var/run/docker.sock", "tcp://0.0.0.0:2376"],
              "tls": true,
              "tlsverify": true,
              "tlscacert": "/etc/docker/certs/ca.pem",
              "tlscert": "/etc/docker/certs/server-cert.pem",
              "tlskey": "/etc/docker/certs/server-key.pem"
            }
            DOCKER_EOF
            
            # Restart Docker
            sudo systemctl daemon-reload
            sudo systemctl restart docker
            
            # Wait for Docker to be ready
            sleep 5
            
            # Verify Docker is running
            docker ps || exit 1
            echo "✅ Docker TLS configured successfully"
          EOF

      - name: Upload client certificates as artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-tls-client-certs
          path: |
            certs/client/ca.pem
            certs/client/cert.pem
            certs/client/key.pem
          retention-days: 7

      - name: Summary
        run: |
          echo "## Infrastructure Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**EC2 IP:** \`${{ steps.get_ip.outputs.EC2_IP }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ **Docker TLS automatically configured!**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Upload client certificates to Railway volume at \`/app/certs\`:" >> $GITHUB_STEP_SUMMARY
          echo "   - \`certs/client/ca.pem\`" >> $GITHUB_STEP_SUMMARY
          echo "   - \`certs/client/cert.pem\`" >> $GITHUB_STEP_SUMMARY
          echo "   - \`certs/client/key.pem\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "2. Deploy terminal container (workflow will run automatically on push to main)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Note:** Client certificates are available in the workflow artifacts (if needed for manual upload)." >> $GITHUB_STEP_SUMMARY
