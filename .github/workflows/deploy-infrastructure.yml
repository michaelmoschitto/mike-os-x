name: Deploy Infrastructure

on:
  push:
    branches: [main]
    paths:
      - 'iac/**'
  workflow_dispatch:
    inputs:
      ssh_public_key:
        description: 'SSH public key for EC2 access (or use EC2_SSH_PUBLIC_KEY secret)'
        required: false
        type: string

jobs:
  deploy-infrastructure:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Pulumi
        uses: pulumi/actions@v5

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        working-directory: iac
        run: bun install

      - name: Validate required secrets
        run: |
          MISSING_SECRETS=()

          if [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ]; then
            MISSING_SECRETS+=("AWS_ACCESS_KEY_ID")
          fi

          if [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
            MISSING_SECRETS+=("AWS_SECRET_ACCESS_KEY")
          fi

          if [ -z "${{ secrets.PULUMI_PASSPHRASE }}" ]; then
            MISSING_SECRETS+=("PULUMI_PASSPHRASE")
          fi

          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "::error::Missing required GitHub secrets: ${MISSING_SECRETS[*]}"
            echo "Please configure these secrets in your repository settings:"
            for secret in "${MISSING_SECRETS[@]}"; do
              echo "  - $secret"
            done
            exit 1
          fi

          echo "✅ All required secrets are configured"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2

      - name: Set Pulumi passphrase
        run: |
          echo "PULUMI_CONFIG_PASSPHRASE=${{ secrets.PULUMI_PASSPHRASE }}" >> $GITHUB_ENV
          echo "AWS_REGION=us-west-2" >> $GITHUB_ENV

      - name: Create S3 bucket for Pulumi state (if needed)
        run: |
          BUCKET_NAME="mike-os-x-pulumi-state"
          if ! aws s3 ls "s3://$BUCKET_NAME" 2>&1 > /dev/null; then
            echo "Creating S3 bucket for Pulumi state..."
            aws s3 mb "s3://$BUCKET_NAME" --region us-west-2
            aws s3api put-bucket-versioning --bucket "$BUCKET_NAME" --versioning-configuration Status=Enabled
            echo "✅ S3 bucket created with versioning enabled"
          else
            echo "✅ S3 bucket already exists"
          fi

      - name: Login to Pulumi (S3 backend)
        run: pulumi login s3://mike-os-x-pulumi-state

      - name: Select or create stack
        working-directory: iac
        run: |
          if ! pulumi stack ls 2>/dev/null | grep -q "default"; then
            pulumi stack init default
          else
            pulumi stack select default
          fi

      - name: Set SSH public key
        working-directory: iac
        run: |
          SSH_KEY="${{ github.event.inputs.ssh_public_key || secrets.EC2_SSH_PUBLIC_KEY }}"
          if [ -z "$SSH_KEY" ]; then
            echo "::error::SSH public key is required but not provided."
            echo "Please either:"
            echo "  1. Set the EC2_SSH_PUBLIC_KEY secret in repository settings, or"
            echo "  2. Provide it as a workflow input when manually triggering the workflow"
            exit 1
          fi
          pulumi config set sshPublicKey "$SSH_KEY"

      - name: Handle existing key pair
        working-directory: iac
        run: |
          # Check if key pair exists in Pulumi state
          if pulumi stack export 2>/dev/null | jq -e '.deployment.resources[] | select(.type == "aws:ec2/keyPair:KeyPair" and .id == "mike-os-x-terminal-key")' > /dev/null 2>&1; then
            echo "✅ Key pair already in Pulumi state"
          else
            # Key pair not in state, check if it exists in AWS
            if aws ec2 describe-key-pairs --key-names mike-os-x-terminal-key --region us-west-2 > /dev/null 2>&1; then
              echo "⚠️  Key pair exists in AWS but not in Pulumi state"
              echo "Deleting orphaned key pair to allow Pulumi to manage it..."
              aws ec2 delete-key-pair --key-name mike-os-x-terminal-key --region us-west-2
              echo "✅ Orphaned key pair deleted, Pulumi will create a new one"
            else
              echo "✅ Key pair doesn't exist in AWS, Pulumi will create it"
            fi
          fi

      - name: Preview changes
        working-directory: iac
        run: pulumi preview --non-interactive

      - name: Deploy infrastructure
        working-directory: iac
        run: pulumi up --yes --non-interactive

      - name: Get EC2 IP
        id: get_ip
        working-directory: iac
        run: |
          EC2_IP=$(pulumi stack output publicIp --show-secrets)
          echo "EC2_IP=$EC2_IP" >> $GITHUB_OUTPUT
          echo "EC2 IP: $EC2_IP"

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ steps.get_ip.outputs.EC2_IP }} >> ~/.ssh/known_hosts

      - name: Wait for EC2 to be ready
        run: |
          echo "Waiting for EC2 instance to be ready..."
          EC2_IP="${{ steps.get_ip.outputs.EC2_IP }}"
          max_attempts=30
          attempt=0

          while [ $attempt -lt $max_attempts ]; do
            if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 -i ~/.ssh/id_rsa ubuntu@$EC2_IP echo "Connected" 2>/dev/null; then
              echo "✅ EC2 instance is ready"
              exit 0
            fi
            attempt=$((attempt + 1))
            echo "Attempt $attempt/$max_attempts: Waiting for SSH..."
            sleep 10
          done

          echo "::warning::EC2 instance may not be fully ready, but continuing..."

      - name: Generate TLS certificates
        run: |
          EC2_IP="${{ steps.get_ip.outputs.EC2_IP }}"
          CERTS_DIR="$(pwd)/certs"
          DAEMON_DIR="$CERTS_DIR/daemon"
          CLIENT_DIR="$CERTS_DIR/client"

          echo "Generating Docker TLS certificates for $EC2_IP..."

          mkdir -p "$DAEMON_DIR" "$CLIENT_DIR"

          # Generate CA private key
          openssl genrsa -out "$CERTS_DIR/ca-key.pem" 4096

          # Generate CA certificate
          openssl req -new -x509 -days 365 -key "$CERTS_DIR/ca-key.pem" \
              -sha256 -out "$CERTS_DIR/ca.pem" \
              -subj "/C=US/ST=State/L=City/O=Organization/CN=docker-ca"

          # Generate server private key
          openssl genrsa -out "$DAEMON_DIR/server-key.pem" 4096

          # Generate server certificate signing request
          openssl req -subj "/C=US/ST=State/L=City/O=Organization/CN=$EC2_IP" \
              -sha256 -new -key "$DAEMON_DIR/server-key.pem" \
              -out "$DAEMON_DIR/server.csr"

          # Create server certificate extensions
          echo "subjectAltName = IP:$EC2_IP,DNS:$EC2_IP,DNS:localhost,IP:127.0.0.1,IP:::1" > "$DAEMON_DIR/server-extfile.cnf"
          echo "extendedKeyUsage = serverAuth" >> "$DAEMON_DIR/server-extfile.cnf"

          # Generate server certificate
          openssl x509 -req -days 365 -sha256 \
              -in "$DAEMON_DIR/server.csr" \
              -CA "$CERTS_DIR/ca.pem" \
              -CAkey "$CERTS_DIR/ca-key.pem" \
              -CAcreateserial \
              -out "$DAEMON_DIR/server-cert.pem" \
              -extfile "$DAEMON_DIR/server-extfile.cnf"

          # Generate client private key
          openssl genrsa -out "$CLIENT_DIR/key.pem" 4096

          # Generate client certificate signing request
          openssl req -subj "/C=US/ST=State/L=City/O=Organization/CN=client" \
              -new -key "$CLIENT_DIR/key.pem" \
              -out "$CLIENT_DIR/client.csr"

          # Create client certificate extensions
          echo "extendedKeyUsage = clientAuth" > "$CLIENT_DIR/client-extfile.cnf"

          # Generate client certificate
          openssl x509 -req -days 365 -sha256 \
              -in "$CLIENT_DIR/client.csr" \
              -CA "$CERTS_DIR/ca.pem" \
              -CAkey "$CERTS_DIR/ca-key.pem" \
              -CAcreateserial \
              -out "$CLIENT_DIR/cert.pem" \
              -extfile "$CLIENT_DIR/client-extfile.cnf"

          # Copy CA cert to client directory
          cp "$CERTS_DIR/ca.pem" "$CLIENT_DIR/ca.pem"

          # Set proper permissions
          chmod 600 "$CERTS_DIR/ca-key.pem" "$DAEMON_DIR/server-key.pem" "$CLIENT_DIR/key.pem"
          chmod 644 "$CERTS_DIR/ca.pem" "$DAEMON_DIR/server-cert.pem" "$CLIENT_DIR/cert.pem"

          # Clean up temporary files
          rm -f "$DAEMON_DIR/server.csr" "$DAEMON_DIR/server-extfile.cnf" \
                "$CLIENT_DIR/client.csr" "$CLIENT_DIR/client-extfile.cnf" \
                "$CERTS_DIR/ca.srl"

          echo "✅ TLS certificates generated successfully"

      - name: Upload server certificates to EC2
        run: |
          EC2_IP="${{ steps.get_ip.outputs.EC2_IP }}"
          mkdir -p /tmp/certs
          cp certs/daemon/* /tmp/certs/
          cp certs/ca.pem /tmp/certs/

          scp -i ~/.ssh/id_rsa -r /tmp/certs/* ubuntu@$EC2_IP:/tmp/certs/
          echo "✅ Server certificates uploaded to EC2"

      - name: Configure Docker TLS on EC2
        run: |
          EC2_IP="${{ steps.get_ip.outputs.EC2_IP }}"
          ssh -i ~/.ssh/id_rsa ubuntu@$EC2_IP << 'EOF'
            set -e
            echo "Configuring Docker TLS..."
            
            # Copy certificates to Docker certs directory
            sudo mkdir -p /etc/docker/certs
            sudo cp /tmp/certs/* /etc/docker/certs/
            sudo chmod 600 /etc/docker/certs/server-key.pem
            sudo chmod 644 /etc/docker/certs/ca.pem /etc/docker/certs/server-cert.pem
            
            # Configure Docker daemon
            sudo tee /etc/docker/daemon.json > /dev/null <<'DOCKER_EOF'
            {
              "hosts": ["unix:///var/run/docker.sock", "tcp://0.0.0.0:2376"],
              "tls": true,
              "tlsverify": true,
              "tlscacert": "/etc/docker/certs/ca.pem",
              "tlscert": "/etc/docker/certs/server-cert.pem",
              "tlskey": "/etc/docker/certs/server-key.pem"
            }
            DOCKER_EOF
            
            # Restart Docker
            sudo systemctl daemon-reload
            sudo systemctl restart docker
            
            # Wait for Docker to be ready
            sleep 5
            
            # Verify Docker is running
            docker ps || exit 1
            echo "✅ Docker TLS configured successfully"
          EOF

      - name: Verify Docker TLS configuration
        run: |
          EC2_IP="${{ steps.get_ip.outputs.EC2_IP }}"
          ssh -i ~/.ssh/id_rsa ubuntu@$EC2_IP << 'EOF'
            set -e
            echo "Verifying Docker TLS configuration..."
            
            # Check certificates exist
            if [ ! -f /etc/docker/certs/ca.pem ] || \
               [ ! -f /etc/docker/certs/server-cert.pem ] || \
               [ ! -f /etc/docker/certs/server-key.pem ]; then
              echo "::error::Missing TLS certificates in /etc/docker/certs/"
              exit 1
            fi
            
            # Check certificate permissions
            if [ "$(stat -c %a /etc/docker/certs/server-key.pem)" != "600" ]; then
              echo "::error::Server key permissions incorrect (should be 600)"
              exit 1
            fi
            
            # Check daemon.json configuration
            if ! grep -q '"tls": true' /etc/docker/daemon.json; then
              echo "::error::Docker daemon.json missing TLS configuration"
              exit 1
            fi
            
            # Check Docker is listening on port 2376
            if ! sudo netstat -tlnp 2>/dev/null | grep -q ':2376' && \
               ! sudo ss -tlnp 2>/dev/null | grep -q ':2376'; then
              echo "::warning::Docker may not be listening on port 2376"
              echo "Checking Docker service status..."
              sudo systemctl status docker --no-pager || true
            fi
            
            # Verify Docker is running
            if ! docker ps > /dev/null 2>&1; then
              echo "::error::Docker is not responding"
              exit 1
            fi
            
            echo "✅ All TLS certificates present"
            echo "✅ Certificate permissions correct"
            echo "✅ Docker daemon.json configured for TLS"
            echo "✅ Docker service is running"
            echo ""
            echo "Docker TLS configuration verified successfully!"
          EOF

      - name: Upload client certificates as artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-tls-client-certs
          path: |
            certs/client/ca.pem
            certs/client/cert.pem
            certs/client/key.pem
          retention-days: 7

      - name: Summary
        run: |
          echo "## Infrastructure Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**EC2 IP:** \`${{ steps.get_ip.outputs.EC2_IP }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ **Docker TLS automatically configured and verified!**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Verification" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ TLS certificates generated and installed" >> $GITHUB_STEP_SUMMARY
          echo "✅ Docker daemon configured for TLS" >> $GITHUB_STEP_SUMMARY
          echo "✅ Docker service running and accessible" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Upload client certificates to Railway volume at \`/app/certs\`:" >> $GITHUB_STEP_SUMMARY
          echo "   - Download \`docker-tls-client-certs\` artifact from this workflow run" >> $GITHUB_STEP_SUMMARY
          echo "   - Upload \`ca.pem\`, \`cert.pem\`, and \`key.pem\` to Railway" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "2. Deploy terminal container (workflow will run automatically on push to main)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Manual Verification" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "To verify locally, SSH to EC2 and run:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "ssh -i ~/.ssh/mike-os-x-ec2 ubuntu@${{ steps.get_ip.outputs.EC2_IP }}" >> $GITHUB_STEP_SUMMARY
          echo "docker ps" >> $GITHUB_STEP_SUMMARY
          echo "sudo systemctl status docker" >> $GITHUB_STEP_SUMMARY
          echo "ls -la /etc/docker/certs/" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
